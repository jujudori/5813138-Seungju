1.quick sort iterative result

<img width="858" alt="image" src="https://github.com/user-attachments/assets/7b9a232d-f288-49d9-8ade-0e212ce71692">

2. 선택, 삽입, 버블, 쉘, 합병정렬과 성능비교

- 구현이 단순하지만 비효율적인 방법 - 삽입/선택/버블
- 구현이 단순하지않지만 효율적인 방법 - 합병/퀵 

선택 - 비교횟수/최악/최선 = O(n²) , 안정된 정렬 X, 단순 구현이 가능하고, 교환횟수가 적음

삽입 - 최악 O(n) 최선O(n²) 평균 O(n²), 안정된 정렬, 레코드작고 대부분 정렬되있을시 효율적

버블 - 최악/최선/평균 = O(n²), 안정된 정렬, 최선의 경우는 자료이동 발생 X , 그러나 순서에 맞지않은 요소를 인접한 요소와 교환하기 때문에 
배열에서 모든 다른 요소들과 교환되어야함. 교환작업이 이동작업보다 복잡함. 거의 쓰이지 않음 

쉘 - 최악 O(n²) 최선 O(n) 평균 O(n¹․⁵), 안정된 정렬 X 삽입정렬에 착안된 정렬이지만 쉘 정렬은 삽입 정렬보다 원거리 자료이동으로 적은 위치교환으로 제자리 찾을 가능성이 높음,
부분 리스트가 어느정도 정렬된 상태이기때문에 쉘 정렬은 기본적으로 삽입정렬을 수행하는것이지만 빠르게 수행된다. << 삽입정렬이 거의 정렬된 리스트에서 빠르게 수행되기 때문

합병 - 최악/최선/평균 = O(nlogn), 안정된 정렬, 입력데이터가 무엇이든 간에 정렬되는 시간은 동일함. 
그러나 임시배열이 필요하고 레코드 크기가 크면 시간낭비 초래 >> 연결리스트를 사용하여 링크 인덱스만 변경되도록 사용시 가장 효율적 

퀵 - 최선/평균 O(nlogn) 최악 O(n²), 안정된 정렬 X 속도가 빠르고 추가 메모리 공간을 필요로 하지않아 효율적임
그러나 정렬된 리스트에서는 오히려 수행시간이 가장 많이 걸린다 >> 이러한 불균형을 방지하기 위해 피벗 선택을 리스트의 중앙부분을 분할 할 수 있는 데이터(중간값)로 선택 

3. 정리
   
레코드가 작은 데이터 : 삽입,쉘	
- 구현이 간단하고 소규모 데이터에서는 속도 차이가 크지 않음

 레코드가 큰 데이터 : 퀵,합병
- 퀵 정렬은 메모리 효율적, 합병 정렬은 안정적

정렬된 데이터 : 삽입 
- 삽입정렬의 최선 성능은 O(n)으로 매우 빠름

메모리 제한 환경	: 퀵 
- 추가 메모리 필요 없음

안정성이 필요한 경우 : 합병,삽입,버블	
- 안정성 보장
